using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Events;
using UnityEngine.EventSystems;

/*
 * 렌더링 파이프라인이란?
 * - 3 차원 공간 상에 존재하는 물체를 화면 상에 출력하기 위해서 거치는 일련의 단계를 의미한다. 
 * (+ 즉, 렌더링 파이프라인은 물체를 화면 상에 출력하기 위한 여러 단계가 존재한다는 것을 
 * 알 수 있다.)
 *
 * 렌더링 파이프라인 종류
 * - 고정 렌더링 파이프라인
 * - 프로그래머블 렌더링 파이프라인
 *
 * 위와 같이 렌더링 파이프라인은 고정 렌더링 파이프라인과 프로그래머블 렌더링 파이프라인으로 
 * 구분되며 고정 렌더링 파이프라인은 현재 거의 사용되지 않는다. (+ 즉, 고정 렌더링 파이프라인은 
 * 과거 쉐이더가 존재하지 않던 시절에 사용되던 렌더링 파이프라인이라는 것을 알 수 있다.)
 *
 * 따라서 현재는 프로그래머블 렌더링 파이프라인이 주로 활용되며 
 * Unity 또한 프로그래머블 렌더링 파이프라인을 통해 특정 물체를 화면 상에 출력한다.
 *
 * 프로그래머블 렌더링 파이프라인 특징
 * - 프로그래머블 렌더링 파이프라인은 이름 그대로 프로그래밍이 가능한 렌더링 파이프라인으로서 물체를
 * 화면 상에 출력하기 위해 필요한 여러 연산 중 일부를 프로그래밍하는 것이 가능하다. (+ 즉, 
 * 렌더링 파이프라인 중 일부 연산을 제어하기 위한 프로그램을 제작하는 것이 가능하다.)
 *
 * 렌더링 파이프라인의 특정 연산을 제어하기 위해서는 쉐이더라고 불리는 프로그램을 제작 할 필요가
 * 있으며 쉐이더는 필요에 따라 생략하는 것이 가능하지만 렌더링 파이프라인의 주요 연산은 반드시 
 * 쉐이더로 제어 할 필요가 있다. (+ 즉, 렌더링 파이프라인의 주요 연산을 제어하기 위한 쉐이더를 
 * 제작하지 않으면 물체를 화면 상에 출력하는 것이 불가능하다는 것을 의미한다.)
 *
 * Unity 는 많은 쉐이더를 지원하며 이를 활용하면 다양한 결과를 화면 상에 출력하는 것이 가능하다.
 * (+ 즉, 쉐이더에 따라 화면 상에 출력되는 결과물이 달라질 수 있다는 것을 의미한다.)
 *
 * 렌더링 파이프라인 주요 연산
 * - 정점 연산
 * - 래스터라이즈 연산
 * - 픽셀 (프래그먼트) 연산
 *
 * 정점 연산이란?
 * - 3 차원 공간 상에 존재하는 데이터 (정점) 를 2 차원 공간 상으로 변환하는 단계를 의미한다. 
 * (+ 즉, 정점 연산을 거치고 나면 2 차원 공간 상에 존재하는 데이터가 계산된다는 것을 알 수 있다.)
 *
 * 3 차원 데이터 -> 2 차원 데이터 변환 과정
 * - 로컬 (모델) 변환
 * - 월드 (전역) 변환
 * - 뷰 (카메라) 변환
 * - 투영 변환
 * - 정규 변환
 * - 화면 변환
 *
 * 위와 같이 3 차원 데이터가 2 차원 데이터로 변환되기 위해서는 여러 단계가 필요하며 정점 연산은
 * 투영 변환까지의 연산을 담당한다. (+ 즉, 정규 변환과 화면 변환은 별도로 처리된다는 것을 
 * 알 수 있다.)
 *
 * 정점 연산은 정점 쉐이더 (Vertex Shader) 에 의해서 처리되며 Unity 는 많은 정점 쉐이더를 
 * 지원한다. (+ 즉, Unity 가 지원하는 정점 쉐이더를 활용하면 간단하게 정점 연산을 처리하는 것이 
 * 가능하다.)
 *
 * 래스터라이즈 연산이란?
 * - 정점 연산에 의해 계산 된 2 차원 데이터를 기반으로 실제 화면 상에 출력 될 픽셀을 계산하는 
 * 단계를 의미한다. (+ 즉, 래스터라이즈 연산을 거치고 나면 완전한 2 차원 데이터가 된다는 것을 
 * 알 수 있다.)
 *
 * 오늘 날 대부분의 출력 장치 (+ Ex. 디스플레이) 는 화소 (픽셀) 을 기반으로 한 
 * 래스터 그래픽 장치이기 때문에 화면 상에 출력 할 물체를 구성하는 픽셀을 계산 할 필요가 있으며 
 * 래스터라이즈 연산에서 이를 처리한다는 것을 알 수 있다.
 *
 * 또한 다른 렌더링 파이프라인 주요 연산과 달리 해당 연산은 쉐이더를 통해 제어하는 것이 불가능하며
 * GPU 에 의해서 처리된다. (+ 즉, 래스터라이즈 연산은 많은 계산이 필요하다는 것을 알 수 있다.)
 *
 * 픽셀 (프래그먼트) 연산이란?
 * - 레스터라이즈 연산에 의해 계산 된 픽셀의 색상을 계산하기 위한 단계를 의미한다. (+ 즉, 
 * 픽셀 연산을 거치고 화면 상에 최종적으로 물체가 출력된다는 것을 알 수 있다.)
 *
 * 픽셀 연산은 화면 상에 출력 될 픽셀의 색상을 계산하는 단계이기 때문에 연산 결과에 따라 실사적인
 * 결과물을 만들어내거나 비실사적인 결과물을 만들어내는 것이 가능하다. (+ 즉, 
 * 픽셀 연산의 결과물에 따라 그래픽 퀄리티에 영향을 미친다는 것을 알 수 있다.)
 *
 * 픽셀 (프래그먼트) 연산은 픽셀 쉐이더 (Pixel Shader or Fragment Shader) 에 의해서 처리되며 
 * Unity 는 많은 픽셀 쉐이더를 지원한다. (+ 즉, Unity 가 지원하는 픽셀 쉐이더를 활용하면 화면 상에 
 * 다양한 결과물을 출력하는 것이 가능하다.)
 * 
 * Unity 프로그래머블 렌더링 파이프라인 종류
 * - URP (Universal Render Pipeline)
 * - HDRP (High Definition Render Pipeline)
 * 
 * Unity 는 위와 같이 SRP (Scriptable Render Piepline) 란 이름으로 
 * 프로그래머블 렌더링 파이프라인을 지원하며 SRP 를 이용하면 다양한 결과물을 화면 상에 출력하는
 * 것이 가능하다.
 * 
 * 단, SRP 는 렌더링 파이프라인을 직접 제작해야되기 때문에 그래픽스에 대한 높은 이해도와 숙련도를
 * 요구하며 따라서 경험이 적은 사용자 (프로그래머) 는 사용하기 어렵다는 단점이 존재한다.
 * 
 * 따라서 Unity 는 SRP 를 기반으로 동작하는 URP (Universal Render Pipeline) 과
 * HDRP (High Definition Render Pipeline) 템플릿을 지원하며 해당 템플릿을 활용하면 
 * 그래픽스에 대한 이해도와 숙련도가 다소 부족하더라도 SRP 를 활용해서 다양한 결과물을 제작하는
 * 것이 가능하다.
 * 
 * URP (Universal Render Pipeline) 란?
 * - 범용 렌더링 파이프라인으로서 모바일을 비롯한 다양한 플랫폼에서 동작하는 결과물을 제작하기 위한
 * 렌더링 파이프라인이다. (+ 즉, 저사양 디바이스도 지원하는 것이 목적이기 떄문에 연산 부하가 높은
 * 작업은 지원하지 않는다는 것을 알 수 있다.)
 * 
 * HDRP (High Definition Render Pipeline) 란?
 * - 고해상도 렌더링 파이프라인으로서 고사양 디바이스를 위한 결과물을 제작 할 수 있는
 * 렌더링 파이프라인이다. (+ 즉, 처음부터 고사양 디바이스를 지원 할 목적으로 제작 된
 * 렌더링 파이프라인이라는 것을 알 수 있다.)
 * 
 * HDRP 를 사용하면 높은 수준의 결과물을 제작하는 것이 가능하지만 많은 연산이 필요하기 때문에
 * 일부 분야를 제외하고는 잘 사용되지 않는 단점이 존재한다. (+ 즉, Unity 는 주로
 * 미들 코어 이하의 결과물을 제작 할 때 주로 활용되는 엔진이기 떄문에 높은 수준의 결과물을
 * 제작하기 위한 HDRP 는 사용률이 떨어진다는 것을 알 수 있다.)
 */
namespace _6x_E01Example
{
	/**
	 * Example 16
	 */
	public partial class C6x_E01Example_16 : CManager_Scene
	{
		#region 변수
		[Header("=====> Example 16 - Game Objects <=====")]
		[SerializeField] private GameObject m_oGameObj_Target = null;
		#endregion // 변수

		#region 함수
		/** 초기화 */
		public override void Awake()
		{
			base.Awake();
		}

		/** 상태를 갱신한다 */
		public override void OnUpdate(float a_fTime_Delta)
		{
			base.OnUpdate(a_fTime_Delta);

			m_oGameObj_Target.transform.Rotate(Vector3.up,
				90.0f * a_fTime_Delta, Space.World);
		}
		#endregion // 함수
	}
}
